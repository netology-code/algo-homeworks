# Домашнее задание к занятию "Пирамиды и деревья поиска"

## Цель задания

1. Уметь обходить и анализировать древовидные структуры
2. Уметь работать с пирамидальными структурами

------

## Инструкция к заданию

1. Для каждой задачи создайте отдельный реплит, если об обратном не сказано в условии
1. Саму программу вы пишете в IDEA, реплит используется только для сдачи кода
1. В окне редактора IDEA наберите программный код, решающий поставленную задачу, на основе данной в условии заготовки кода
1. Загружаете файлы из папки src проекта в реплит
1. Отправьте выполненную работу на проверку в личном кабинете Нетологии

------

## Материалы, которые пригодятся для выполнения задания

1. [Структуры данных: двоичное дерево в Java](https://javarush.com/groups/posts/3111-strukturih-dannihkh-dvoichnoe-derevo-v-java)
1. [Структуры данных: пирамида (двоичная куча) в Java](https://javarush.com/groups/posts/3083-strukturih-dannihkh-piramida-dvoichnaja-kucha-v-java)
3. [Как поделиться реплитом для проверки?](https://github.com/netology-code/java-homeworks/blob/java-43/QA_ReplitShare.md)
4. [Как автоотформатировать код?](https://github.com/netology-code/java-homeworks/blob/java-43/QA_Format.md)
5. [Как залить проект из IDEA в реплит?](https://github.com/netology-code/java-homeworks/blob/java-43/QA_ReplitUpload.md)

------

## Задание 1 (обязательное)

Вам дана реализация бинарного дерева поиска на именах.
Имена сравниваются в естественном (лексикографическом) порядке, т.е. как в словаре.
В левом поддереве всегда лежат имена лексикографически меньшие (т.е. которые в словаре лежали бы раньше) чем то что находится в узле, а в правом - лексикографически большие.

Дерево при этом идеально сбалансировано, т.е. по структуре связей между узлами подошло бы и для пирамиды.
Ваша задача как раз и состоит в том, чтобы проверить заданное дерево на min-пирамидальность по длине имён.
Т.е. мы хотим проверить, что это дерево является пирамидой на минимум, если сравнение делать через сравнение длин имён.
Ваш метод не должен перепроверять сбалансированность дерева и он может считать, что она уже гарантируется.

Пример дерева, на которое ваш метод должен сказать ДА:

<img width="1293" alt="image" src="https://user-images.githubusercontent.com/53707586/216814800-519002b9-13a0-4c83-a1c9-3f12756eab25.png">


Пример дерева, на которое ваш метод должен сказать НЕТ (длина имени "Павел" меньше, чем длина имени "Константин", что нарушает пирамидальность):

<img width="1296" alt="image" src="https://user-images.githubusercontent.com/53707586/216814848-5ae11630-3cd1-45d4-adec-65b30dd6fc35.png">



### Заготовка кода
Используйте этот код в качестве заготовки кода вашего проекта. Менять код в `main` нельзя.

```java
```

### Алгоритм

------


## Правила приема работы

Прикреплён реплит с решением задачи

------

## Критерии оценки

1. Программа оформлена на основе заготовки кода, предоставленной в условии
1. Программа запускается и отрабатывает без ошибок
2. Программа соответствует всем требованиям из условия задачи
3. Программа работает правильно на всех примерах из условия
4. Программный код соответствует пройденным требованиям к качеству кода
5. Программа спроектирована достаточно логично и правильно, не противоречит общепринятым в производстве практикам и традициям
6. Программа реализует достаточный для зачёта по эффективности алгоритм
7. При наличии недочётов, в зависимости от их серьёзности и количества, работа может быть отправлена на доработку или принята; решение принимается на основе экспертной оценки работы.
