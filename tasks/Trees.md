# Домашнее задание к занятию 5. Пирамиды и бинарные деревья поиска
### Инструкция по выполнению домашнего задания:
**1.** Зарегистрируйтесь на сайте **[repl.it](https://repl.it/)**;<br>
**2.** Перейдите в раздел **my repls**;<br>
**3.** Нажмите кнопку **Start coding now**! - если вы приступаете впервые, или **New Repl** - если у вас уже есть работы;<br>
**4.** В списке языков выберите тот **язык, который изучаете**;<br>
**5.** Код пишите в левой части окна - **в редакторе кода**;<br>
**6.** Чтобы посмотреть результат выполнения файла, нажмите на кнопку **Run**. Результат появится в правой части окна;<br>
**7.** После окончания работы скопируйте **ссылку на ваш repl** в адресной строке браузера;<br>
**8.** Скопированную ссылку (ваше решение ДЗ) нужно отправить на проверку. Для этого перейдите в личный кабинет на сайте **[netology.ru](https://netology.ru/)**, в поле комментария к домашней работе вставьте скопированную ссылку и отправьте работу на проверку;

------------

## Построение идеального биндерева поиска

У вас есть отсортированный массив двузначных чисел без повторов размером в 2<sup>k</sup>-1 для какого-нибудь k, т.е. вам гарантируется что размер может быть 3 (2<sup>2</sup>-1), 15 (2<sup>4</sup>-1), 1023 (2<sup>10</sup>-1), но не 11 или 30. Это позволит вам не заморачиваться с проблемами при делении пополам :)

Вам надо написать функцию, которая возьмёт этот массив и выведет на экран бинарное дерево поиска из элементов этого дерева, которое будет полным двоичным деревом. Условие на размер массива гарантирует, что такое дерево всегда можно построить, более того, только на последнем уровне у узлов не будет детей.

Например, у вас есть массив `[10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52]`.

Вам надо вывести бинарное дерево в таком виде:
```
              31              
      19              43      
  13      25      37      49  
10  16  22  28  34  40  46  52
```

Заметьте, что стрелочки мы не рисовали, но кто является чьим ребёнком можно догадаться: у `31` ребёнок `19` и `43`, у `25` - `22` и `28`, у `43` - `37` и `49`. Для каждого узла дерева соблюдается требование, наложенное на бинарные деревья поиска - левый ребёнок и все его потомки меньше, правый и все его потомки - больше.

Асимптотика в данном задании не важна.

### Решение
Давайте сперва найдём для каждого элемента массива уровень дерева, на котором он должен быть (корень на нулевом уровне, дальше по увеличению).

Тк такое полное бинарное дерево симметрично в плане своей структуры, мы знаем, что слева от корня будет столько же элементов, сколько и справа. Если мы возьмём элемент посередине массива, то слева и справа будет одинаковое количество элементов, также благодаря отсортированности слева будут элементы только меньшие, а справа только большие. Значит этот элемент и есть корень нашего дерева и его уровень 0.

Решим задачу рекурсивно: левым ребёнком у корня будет элемент, который был бы корнем полного бинарного дерева поиска, запусти мы алгоритм от левой половины исходного массива. Аналогично для правого ребёнка.

Учитывая всё вышесказанное, давайте напишем рекурсивную функцию `mark`, которая принимает массив, левую и правую границы рассматриваемого участка массива, текущий уровень и массив, куда для каждого элемента исходного массива мы запишем его уровень в дереве. Результатом вызова этой функции `mark(arr, 0, длина(arr) - 1, 0, пустой массив levels)` в массиве `levels` в каждой ячейке будет лежать уровень элемента в дереве.

```
mark(arr, left, right, level, levels):
  if left == right
    levels[left] = level
    выход
  middle = (left + right) / 2
  levels[middle] = level
  mark(arr, left, middle - 1, level + 1, levels)
  mark(arr, middle + 1, right, level + 1, levels)
```

После того как мы разметим каждый элемент на соответствующий уровень, будем выводить уровни дерева по очереди, построчно. Для этого пройдёмся циклом со счётчиком текущего уровня, а для каждого уровня пройдёмся циклом по массиву меток. Если для элемента в массиве уровней стоит наш текущий выводимый уровень, то мы напечатаем элемент, если нет, то напечатаем пропуск.

```
build(arr):
  levels = [длина(arr) нулей]
  mark(arr, 0, длина(arr) - 1, 0, levels)
  for level от 0 до максимум_среди(levels) + 1
    for i от 0 до длина(arr):
      if levels[i] == level:
        напечатаем arr[i]
      else:
        напечатаем два пробела, тк числа двузначные
    напечатаем перенос строки
```

### Реализация
1. Создайте массив и заполните его из примера
2. Напишите функции `mark` и `build`
3. Вызовите функцию `build` от массива, убедитесь, что вывод совпал с тем что в примере
4. *(необязательно)* Оцените алгоритмическую сложность алгоритма, сколько он занимает времени и памяти. Аргументируйте, почему вы так считаете.
5. Загрузите ваше решение на сайт **[repl.it](https://repl.it/)**, отправьте ссылку на него на проверку.
