# Домашнее задание к занятию 8. Ориентированные графы
### Инструкция по выполнению домашнего задания:
**1.** Зарегистрируйтесь на сайте **[repl.it](https://repl.it/)**;<br>
**2.** Перейдите в раздел **my repls**;<br>
**3.** Нажмите кнопку **Start coding now**! - если вы приступаете впервые, или **New Repl** - если у вас уже есть работы;<br>
**4.** В списке языков выберите тот **язык, который изучаете**;<br>
**5.** Код пишите в левой части окна - **в редакторе кода**;<br>
**6.** Чтобы посмотреть результат выполнения файла, нажмите на кнопку **Run**. Результат появится в правой части окна;<br>
**7.** После окончания работы скопируйте **ссылку на ваш repl** в адресной строке браузера;<br>
**8.** Скопированную ссылку (ваше решение ДЗ) нужно отправить на проверку. Для этого перейдите в личный кабинет на сайте **[netology.ru](https://netology.ru/)**, в поле комментария к домашней работе вставьте скопированную ссылку и отправьте работу на проверку;

------------

## Задача о вирусном меме

Представим себе социальную сеть. В ней зарегистрированы пользователи, у каждого пользователя есть список людей, которым он пересылает мемы. Заметим, что если пользователь А пересылает мемы пользователю B, это необязательно значит, что пользователь B пересылает мемы пользователю А. Если пользователю прислали мем, то он его прочтёт ровно через 55 минут и через 5 минут отправит всем из своего списка людей если до того его ни разу не отправлял.

Такие данные легко представить в виде ориентированного графа: вершинами будут люди, а из вершины A будет дуга в вершину B, если пользователь A пересылает мемы напрямую пользователю B. Давайте реализуем этот граф:

```
Graph:
  vertices_info - изначально массив из V пустых множеств / списков
  
  add_edge(a, b):
    vertices_info[a].add(b)
    vertices_info[b].add(a)
  
  nexts(v):
    return vertices_info[v]
  
  vertices():
    return номера от 0 до V
  
  size():
    return V
```

Перед вами стоит задача: вам дан такой социальный граф и номер пользователя, который увидел где-то какой-то мем и начал его пересылать. Каждый пользователь, который получил мем, также начал пересылать мемы. Вам нужно найти номер пользователя, который увидит впервые этот мем самым последним по времени. Если таковых несколько, подойдёт любой из них.

Например, пусть у вас есть 7 пользователей сети. Пользователь с номером 0 всегда пересылает мемы пользователям 1 и 3, а пользователь с номером 1 - пользователям 2 и 3. Если пользователь с номером 0 в 10:00 увидел мем и в 10:05 начнёт пересылать мемы, то:

1. 10:05. Пользователь 0 отправил мемы пользователю 1 и 3
2. 11:00. Пользователь 1 и 3 получили мем
3. 11:05. Пользователь 3 никому не отправляем мемы, а пользователь 1 отправил мемы пользователям 2 и 3.
4. 12:00. Пользователь 2 и 3 получили мем. Пользователь 2 получил его впервые, а пользователь 3 уже получал его на час раньше от пользователя 0. Пользователь 2 ни с кем не делится мемами, а пользователь 3 уже пересылал мем час назад, пересылки мема на этом закончились.

Кто когда впервые увидел мем:
| Пользователь | Когда впервые увидел мем |
| -- | -- |
| 0 | 10:00 |
| 1 | 11:00 |
| 2 | 12:00 |
| 3 | 11:00 |
| 4 | никогда |
| 5 | никогда |
| 6 | никогда |

Ответом к задаче на данном примере будет пользователь с номером 2.

Как же решить эту задачу? Давайте сделаем это на основе обхода в ширину. Для этого сначала заведём массив меток - для каждой вершины будем хранить информацию о том, получал ли пользователь уже этот мем. Также заведём пустую очередь, в которую будем складывать пользователей.

```
virusize_meme(graph, start_user):
  visited = [V раз нет]
  sent = пустая очередь
  ...
```

Добавим в очередь стартового пользователя, который начнёт рассылку мемов. Пометим, что он уже видел мем:
```
virusize_meme(graph, start_user):
  ...
  visited[start_user] = да
  добавить start_user в sent
  ...
```

Теперь будем поочерёдно доставать пользователей и для каждого добавлять в неё тех, кому он отправит мем, но за исключением тех людей, которые уже его видели. Тот пользователь, которого мы достанем из очереди последним (когда он не сможет никому отправить из тех кто ещё не видел мем), и будет искомым ответом:
```
virusize_meme(graph, start_user):
  ...
  while sent не пустая:
    last_viewer = вынем из sent следующего пользователя
    for v среди graph.nexts(last_viewer):
      if не visited[v]:
        visited[v] = да
        добавим v в sent
  напечатаем "Последним увидет: " last_viewer
```

**Примечание.** Заметьте, мы даже не использовали нигде информацию о 55 и 5 минутах, это оказалось не важно. А вот если бы каждый пользователь отправлял или читал бы мемы с разной скоростью, то нам пришлось бы это использовать и решать через модифицированный алгоритм Дейкстры.

### Реализация
1. Реализуйте структуру данных ориентированный граф для хранения информации о пользователях и тех, кому они пересылают мемы.
2. Реализуйте модифицированный алгоритм обхода в ширину для решения задачи.
3. Создайте граф, заполнив его информацией из примера про 7 пользователей.
4. Запустите решение вашей задачи на этом графе, убедитесь что она выдаёт правильный ответ (дан выше).
5. Загрузите ваше решение на сайт **[repl.it](https://repl.it/)**, отправьте ссылку на него на проверку.
