# Домашнее задание к занятию "Введение в алгоритмы и структуры данных"

## Цель задания

1. Реализовать первую алгоритмическую задачу
2. Применить идеи бинарного поиска в решении задачи

------

## Инструкция к заданию

1. Для каждой задачи создайте отдельный реплит, если об обратном не сказано в условии
1. Саму программу вы пишете в IDEA, реплит используется только для сдачи кода
1. В окне редактора IDEA наберите программный код, решающий поставленную задачу, на основе данной в условии заготовки кода
1. Загружаете файлы из папки src проекта в реплит
1. Отправьте выполненную работу на проверку в личном кабинете Нетологии

------

## Материалы, которые пригодятся для выполнения задания

1. Бинарный поиск в [6 алгоритмов поиска на Java: от простого к сложному](https://proglib.io/p/6-search-algorithms-java)
2. [Как поделиться реплитом для проверки?](https://github.com/netology-code/java-homeworks/blob/java-43/QA_ReplitShare.md)
3. [Как автоотформатировать код?](https://github.com/netology-code/java-homeworks/blob/java-43/QA_Format.md)
4. [Как залить проект из IDEA в реплит?](https://github.com/netology-code/java-homeworks/blob/java-43/QA_ReplitUpload.md)

------

## Задание 1 (обязательное)

Вам надо написать алгоритм для сувенирного магазина.
Вам известен его ассортимент в виде массива цен (названия товаров нам не важны). Массив отсортирован в порядке возрастания.
Клиенты могут оформлять подарочные сертификаты на определённую сумму, ваша задача по сумме сертификата находить количество товаров, которые невозможно будет на него приобрести (т.е. количество товаров, цена которых выше сертификата).

### Пример
Пусть массив цен выглядит следующим образом: `[13, 17, 19, 25, 25, 25, 25, 25, 25, 27, 30]`.

Тогда ответы будут такие:
| Сертификат | Количество недоступных товаров | Комментарий |
| --- | --- | --- |
| 31 | 0 | Все товары дешевле |
| 26 | 2 | Дороже только два товара |
| 25 | 2 | Дороже только два товара |
| 20 | 8 | Дороже все начиная с 25 |

### Заготовка кода
Используйте этот код в качестве заготовки кода вашего проекта. Менять код в `main` нельзя.

```java
public class Main {

    public static void main(String[] args) {
        int[] prices = { 13, 17, 19, 25, 25, 25, 25, 25, 25, 27, 30 };

        System.out.println("Для 31: " + countMore(prices, 31)); // 0
        System.out.println("Для 26: " + countMore(prices, 26)); // 2
        System.out.println("Для 25: " + countMore(prices, 25)); // 2
        System.out.println("Для 20: " + countMore(prices, 20)); // 8
    }

    public static int countMore(int[] prices, int money) {
        // Ваш алгоритм
    }
}
```

### Алгоритм

Первая мысль решения задачи может быть использование прямого перебора для подсчёта количества товаров, цена которых выше денег на сертификате. 
Асимптотика такого алгоритма будет `O(n)`.
```java
    public static int countMore(int[] prices, int money) {
        int count = 0;
        for (int price : prices) {
            if (price > money) {
                count++;
            }
        }
        return count;
    }
```

Можно улучшить алгоритм, заметив, что массив цен уже отсортирован и наткнувшись на первый недоступный по цене товар, мы можем быть уверены, что все оставшиеся также недоступны. Тогда алгоритм преобразуется вот так:
```java
    public static int countMore(int[] prices, int money) {
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] > money) {
                return prices.length - i; // сколько осталось товаров
            }
        }
        return 0; // если не нашли ни одного товара дороже
    }
```

Хоть этот алгоритм и будет работать быстрее, его асимптотика всё ещё будет линейной, а если по цене доступны почти все товары, то эффективность улучшения будет едва заметна.

Вам предлагается написать более эффективное решение - бинарный поиск.
Нам достаточно уметь находить первый недоступный товар в массиве, ведь тогда мы сразу сможем найти количество недоступных товаров (как в последней версии алгоритма).

Найти это место можно бинарным поиском.
Обратите внимание, что посмотрев на любой из товаров, мы можем сразу определить в какую сторону (лево или право) нам следует продолжить поиск первого недоступного товара. А именно: если товар допустимый, то нужно искать влево, а если недопустимый то искать вправо, если предыдущий к нему тоже недопустимый.

Реализуйте метод поиска, основанный на бинарном поиске (таким образом, имеющий O(log n) асимптотику):
```java
public static int countMore(int[] prices, int money) {
        if (prices[0] > money) {
            return prices.length; // все недоступны
        }

        if (prices[prices.length - 1] < money) {
            return 0; // все доступны
        }

        int left = 0;
        int right = prices.length - 1;
        while (left < right) {
            int middle = (left + right) / 2;
            // Ваш код
        }
        return 0;
    }
```

------


## Правила приема работы

Прикреплён реплит с решением задачи

------

## Критерии оценки

1. Программа оформлена на основе заготовки кода, предоставленной в условии
1. Программа запускается и отрабатывает без ошибок
2. Программа соответствует всем требованиям из условия задачи
3. Программа работает правильно на всех примерах из условия
4. Программный код соответствует пройденным требованиям к качеству кода
5. Программа спроектирована достаточно логично и правильно, не противоречит общепринятым в производстве практикам и традициям
6. Программа реализует достаточный для зачёта по эффективности алгоритм
7. При наличии недочётов, в зависимости от их серьёзности и количества, работа может быть отправлена на доработку или принята; решение принимается на основе экспертной оценки работы.
